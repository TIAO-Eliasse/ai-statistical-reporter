"""
Chapter-by-Chapter Report Generator
GÃ©nÃ¨re un rapport complet chapitre par chapitre avec validation humaine
VERSION CORRIGÃ‰E ET AMÃ‰LIORÃ‰E - DÃ©cembre 2025

CORRECTIONS MAJEURES :
[OK] Gestion robuste des erreurs Python (KeyError, TypeError)
[OK] DÃ©codage des variables encodÃ©es
[OK] InterprÃ©tations obligatoires aprÃ¨s CHAQUE tableau/graphique
[OK] RÃ©fÃ©rences correctes (tableau vs graphique)
[OK] Support Excel + CSV
[OK] Gestion apostrophes dans noms de colonnes
"""

from typing import Dict, List, Optional
from enum import Enum
import logging
from datetime import datetime

# Imports des modules prÃ©cÃ©dents
from e2b_session_manager import get_sandbox_for_user, execute_python_code
from contextual_memory import (
    add_chapter_to_memory,
    get_context_for_chapter,
    contextual_memory
)
from table_formatter import TableFormatter

logger = logging.getLogger(__name__)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE AUTO-REVIEW INTÃ‰GRÃ‰ v2.5 - Powered by Gemini 2.0 Flash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

REVIEW_PROMPT = """Tu es un statisticien senior et reviewer professionnel.

[SEARCH] ANALYSE : CrÃ©dibilitÃ© statistique, qualitÃ© analytique, lisibilitÃ© professionnelle
ğŸ› ï¸ PRODUIS : 1ï¸âƒ£ Critique 2ï¸âƒ£ AmÃ©liorations 3ï¸âƒ£ Recommandations prompts 4ï¸âƒ£ Principes

RAPPORT : {report_content}
"""


def auto_review_report(report_markdown: str) -> dict:
    """Auto-review du rapport avec Gemini 2.0 Flash"""
    try:
        import google.generativeai as genai
        import os
        
        # Configurer Gemini
        api_key = os.environ.get("GEMINI_API_KEY") or os.environ.get("GOOGLE_API_KEY")
        if not api_key:
            return {'success': False, 'error': 'GEMINI_API_KEY ou GOOGLE_API_KEY non trouvÃ©e'}
        
        genai.configure(api_key=api_key)
        
        # Utiliser Gemini 2.0 Flash
        model = genai.GenerativeModel('gemini-2.0-flash-exp')
        
        logger.info("Lancement auto-review avec Gemini 2.0 Flash...")
        
        # GÃ©nÃ©rer la review
        prompt = REVIEW_PROMPT.format(report_content=report_markdown[:50000])
        response = model.generate_content(prompt)
        
        review_text = response.text
        logger.info("Auto-review terminÃ©e")
        
        # Parser sections
        sections = {}
        for emoji, key in [("1ï¸âƒ£", "critique"), ("2ï¸âƒ£", "ameliorations"), 
                            ("3ï¸âƒ£", "prompt_recommendations"), ("4ï¸âƒ£", "principles")]:
            if emoji in review_text:
                start = review_text.find(emoji)
                next_emoji = ["2ï¸âƒ£", "3ï¸âƒ£", "4ï¸âƒ£", None]
                next_idx = ["2ï¸âƒ£", "3ï¸âƒ£", "4ï¸âƒ£", None].index(None) if emoji == "4ï¸âƒ£" else ["1ï¸âƒ£", "2ï¸âƒ£", "3ï¸âƒ£", "4ï¸âƒ£"].index(emoji) + 1
                end = review_text.find(next_emoji[next_idx]) if next_idx < 4 and next_emoji[next_idx] else len(review_text)
                sections[key] = review_text[start:end].strip()
        
        return {'success': True, 'full_review': review_text, **sections}
    except Exception as e:
        logger.error(f"Auto-review error: {e}")
        return {'success': False, 'error': str(e)}


class ChapterStatus(Enum):
    """Statuts possibles d'un chapitre"""
    PENDING = "En attente"
    GENERATING = "GÃ©nÃ©ration en cours"
    GENERATED = "GÃ©nÃ©rÃ© (en attente validation)"
    VALIDATED = "ValidÃ©"
    REJECTED = "RejetÃ© (Ã  regÃ©nÃ©rer)"
    ERROR = "Erreur"


class Chapter:
    """ReprÃ©sente un chapitre du rapport"""
    
    def __init__(self, number: str, title: str, sections: List[Dict]):
        self.number = number
        self.title = title
        self.sections = sections
        self.status = ChapterStatus.PENDING
        self.content: Optional[str] = None
        self.generated_at: Optional[datetime] = None
        self.validated_at: Optional[datetime] = None
        self.error_message: Optional[str] = None
        self.attempts = 0
        self.regeneration_instructions: Optional[Dict] = None
    
    def to_dict(self) -> dict:
        return {
            'number': self.number,
            'title': self.title,
            'sections': self.sections,
            'status': self.status.value,
            'content': self.content,
            'generated_at': self.generated_at.isoformat() if self.generated_at else None,
            'validated_at': self.validated_at.isoformat() if self.validated_at else None,
            'error_message': self.error_message,
            'attempts': self.attempts,
            'regeneration_instructions': self.regeneration_instructions
        }



class ReportGenerationWorkflow:
    """
    Workflow de gÃ©nÃ©ration de rapport avec validation humaine
    
    Process:
    1. Charger le plan du rapport
    2. Pour chaque chapitre:
       a. GÃ©nÃ©rer le chapitre (IA + E2B)
       b. Afficher Ã  l'utilisateur
       c. Attendre validation
       d. Si validÃ©: passer au suivant
       e. Si rejetÃ©: regÃ©nÃ©rer
    3. Compiler tous les chapitres en rapport final
    """
    
    def __init__(self, user_id: str, plan: Dict, csv_path: str, cost_controller=None, study_context=None):
        self.user_id = user_id
        self.plan = plan
        self.csv_path = csv_path
        self.cost_controller = cost_controller
        self.study_context = study_context
        self.chapters: List[Chapter] = []
        self.current_chapter_index = 0
        
        # Initialiser les chapitres depuis le plan
        self._initialize_chapters()
        
        # Charger la mÃ©moire contextuelle
        contextual_memory.load_memory(user_id)
        
        logger.info(f"Workflow initialized for user {user_id}: {len(self.chapters)} chapters")
        
        if cost_controller:
            logger.info(f"Cost controller enabled - Total target: {cost_controller.get_total_pages()} pages")
        
        if study_context:
            logger.info(f"Study context available: {study_context.study_title or 'Untitled'}")
    
    def _initialize_chapters(self):
        """Initialise la liste des chapitres depuis le plan"""
        for chapter_data in self.plan.get('chapitres', []):
            chapter = Chapter(
                number=chapter_data['numero'],
                title=chapter_data['titre'],
                sections=chapter_data.get('sections', [])
            )
            self.chapters.append(chapter)
    
    def get_current_chapter(self) -> Optional[Chapter]:
        """Retourne le chapitre en cours de traitement"""
        if self.current_chapter_index < len(self.chapters):
            return self.chapters[self.current_chapter_index]
        return None
    
    def generate_current_chapter(self) -> Dict:
        """
        GÃ©nÃ¨re le chapitre en cours
        
        Returns:
            {
                'success': bool,
                'chapter': Chapter,
                'content': str (si success),
                'error': str (si Ã©chec)
            }
        """
        chapter = self.get_current_chapter()
        
        if not chapter:
            return {
                'success': False,
                'chapter': None,
                'error': "Aucun chapitre Ã  gÃ©nÃ©rer"
            }
        
        logger.info(f"Generating chapter {chapter.number}: {chapter.title}")
        
        chapter.status = ChapterStatus.GENERATING
        chapter.attempts += 1
        
        try:
            # 1. RÃ©cupÃ©rer le contexte des chapitres prÃ©cÃ©dents
            context = get_context_for_chapter(self.user_id, chapter.number)
            
            # 2. Construire le prompt pour l'IA (avec instructions de rÃ©gÃ©nÃ©ration si disponibles)
            prompt = self._build_chapter_prompt(chapter, context)
            
            # 3. DÃ©terminer le type de tÃ¢che selon le chapitre
            task_type = self._detect_task_type(chapter)
            logger.info(f"Detected task type for chapter {chapter.number}: {task_type}")
            
            # 4. GÃ©nÃ©rer le contenu avec l'IA (modÃ¨le spÃ©cialisÃ©)
            content = self._generate_with_ai(prompt, task_type=task_type)
            
            # 5. ExÃ©cuter le code Python dans E2B si nÃ©cessaire
            content_with_results = self._execute_code_blocks(content)
            
            # 6. Mettre Ã  jour le chapitre
            chapter.content = content_with_results
            chapter.status = ChapterStatus.GENERATED
            chapter.generated_at = datetime.now()
            
            logger.info(f"Chapter {chapter.number} generated successfully ({len(content_with_results)} chars)")
            
            return {
                'success': True,
                'chapter': chapter,
                'content': content_with_results
            }
        
        except Exception as e:
            import traceback
            full_traceback = traceback.format_exc()
            logger.error(f"Failed to generate chapter {chapter.number}: {e}")
            logger.error(f"FULL TRACEBACK:\n{full_traceback}")
            
            chapter.status = ChapterStatus.ERROR
            chapter.error_message = str(e)
            
            return {
                'success': False,
                'chapter': chapter,
                'error': str(e)
            }
    
    def _detect_task_type(self, chapter: Chapter) -> str:
        """
        DÃ©tecte le type de tÃ¢che selon le numÃ©ro et titre du chapitre
        
        Returns:
            "code", "writing", "analysis", "plan", ou "default"
        """
        title_lower = chapter.title.lower()
        
        # Chapitres nÃ©cessitant beaucoup de code/graphiques
        if any(keyword in title_lower for keyword in [
            "prÃ©sentation", "description", "distribution", "visualisation"
        ]):
            return "code"
        
        # Chapitres d'analyse/interprÃ©tation
        elif any(keyword in title_lower for keyword in [
            "analyse", "relation", "corrÃ©lation", "test", "interprÃ©tation", 
            "comparaison", "diffÃ©rence"
        ]):
            return "analysis"
        
        # Chapitres de conclusion/synthÃ¨se
        elif any(keyword in title_lower for keyword in [
            "conclusion", "synthÃ¨se", "recommandation", "discussion"
        ]):
            return "writing"
        
        # Introduction (mix de writing et code)
        elif "introduction" in title_lower:
            return "writing"
        
        # Par dÃ©faut
        else:
            return "default"
    
    def _build_chapter_prompt(self, chapter: Chapter, context: str) -> str:
        """
        Construit le prompt pour gÃ©nÃ©rer un chapitre
        VERSION ULTRA-ORGANISÃ‰E - Structure hiÃ©rarchique claire
        """
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # COLLECTE DES INFORMATIONS (comme dans l'original)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        csv_columns_info = ""
        try:
            import pandas as pd
            import os
            
            file_extension = os.path.splitext(self.csv_path)[1].lower()
            
            if file_extension in ['.xlsx', '.xls']:
                df_temp = pd.read_excel(self.csv_path)
                file_type_label = "EXCEL"
            else:
                df_temp = pd.read_csv(self.csv_path)
                file_type_label = "CSV"
            
            columns_list = df_temp.columns.tolist()
            columns_types = df_temp.dtypes.to_dict()
            
            # Construction des infos colonnes
            csv_columns_info = f"""
    ğŸ“ FICHIER {file_type_label} : {len(df_temp)} lignes

    COLONNES DISPONIBLES (utilisez SEULEMENT celles-ci) :
    """
            for col in columns_list[:20]:  # Limiter affichage
                dtype = str(columns_types[col])
                example = str(df_temp[col].iloc[0]) if len(df_temp) > 0 else "N/A"
                csv_columns_info += f"  â€¢ \"{col}\" ({dtype}, ex: {example})\n"
            
            if len(columns_list) > 20:
                csv_columns_info += f"  â€¢ ... et {len(columns_list) - 20} autres colonnes\n"
            
        except Exception as e:
            logger.error(f"Failed to read data: {e}")
            csv_columns_info = "[WARNING] Impossible de lire les colonnes du fichier.\n"
        
        # RÃ©cupÃ©rer contraintes de longueur
        length_guidelines = ""
        if self.cost_controller:
            try:
                from cost_controller import get_length_guidelines
                config = self.cost_controller.get_chapter_config(chapter.number)
                if config:
                    length_guidelines = f"\nğŸ“ LONGUEUR CIBLE : {config.target_pages} pages (~{config.target_words} mots)\n"
            except Exception as e:
                logger.warning(f"Failed to get length guidelines: {e}")

        study_context_section = ""
                
        writing_style_block = ""

        if self.study_context:
            try:
                # Contexte de l'Ã©tude
                study_context_section = f"""
        {self.study_context.to_prompt_context()}

        [WARNING] IMPORTANT : Utilisez ce contexte pour guider TOUTE votre analyse !
        - RÃ©pondez Ã  la question de recherche
        - Testez les hypothÃ¨ses formulÃ©es
        - Atteignez les objectifs dÃ©finis
        - Adaptez le style au public cible

        """
                
                # NOUVEAU : Bloc de style d'Ã©criture selon le profil
                try:
                    writing_style_block = self.study_context.get_writing_style_block()
                    logger.info(f"Chapter {chapter.number}: Writing profile {self.study_context.writing_profile.value} injected")
                except Exception as e:
                    logger.warning(f"Failed to inject writing style: {e}")
                    writing_style_block = ""
                
                logger.info(f"Chapter {chapter.number}: Study context injected")
            
            except Exception as e:
                logger.warning(f"Failed to inject study context: {e}")
        # Instructions de rÃ©gÃ©nÃ©ration
        regeneration_instructions = ""
        if hasattr(chapter, 'regeneration_instructions') and chapter.regeneration_instructions:
            instructions = chapter.regeneration_instructions
            regeneration_instructions = f"""
    [REFRESH] RÃ‰GÃ‰NÃ‰RATION DEMANDÃ‰E : {instructions.get('request', '')}
    {"[OK] Conserver structure" if instructions.get('keep_structure') else "ğŸ†• Modifier si nÃ©cessaire"}
    """
        elif chapter.status == ChapterStatus.REJECTED and chapter.error_message:
            regeneration_instructions = f"\n[REFRESH] RAISON DU REJET : {chapter.error_message}\n"
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # CONSTRUCTION DU PROMPT HIÃ‰RARCHISÃ‰
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        prompt = f"""
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                                                              â•‘
    â•‘         GÃ‰NÃ‰RATION CHAPITRE {chapter.number} : {chapter.title}                              â•‘
    â•‘                                                                              â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘ SECTION 1 : DONNÃ‰ES & CONTEXTE DISPONIBLES                                  â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    {csv_columns_info}

    {context}

    {study_context_section}
    {writing_style_block}
    {regeneration_instructions}

    {length_guidelines}


    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘ SECTION 2 : VOTRE MISSION                                                   â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    [WARNING] RÃˆGLE ULTRA-IMPORTANTE : LE CODE NE DOIT PAS APPARAÃTRE DANS LE RAPPORT !

    ğŸ”´ FONCTIONNEMENT DU SYSTÃˆME :
    1. Tu Ã©cris le code entre ```python et ```
    2. Le systÃ¨me l'EXÃ‰CUTE automatiquement dans E2B
    3. Le CODE est SUPPRIMÃ‰ du rapport final
    4. Seuls les RÃ‰SULTATS (tableaux, graphiques, print) apparaissent
    ğŸ”´ PRINCIPE DE NON-RÃ‰PÃ‰TITION :
    - Une fois qu'un rÃ©sultat est affichÃ© (tableau/graphique), NE PAS le rÃ©gÃ©nÃ©rer
    - Si vous devez ajuster, utilisez les donnÃ©es dÃ©jÃ  calculÃ©es
    - Exemple :
    
    [OK] CORRECT :
````
    [Code 1 â†’ Tableau 1.1]
    afficher tableau
    le code ne doit jamais etre afficher dans le rapport
    InterprÃ©tation...
    
    [Code 2 â†’ Tableau 1.2 - NOUVEAU rÃ©sultat]
    afficher tableau
    InterprÃ©tation...
    [Code 3 â†’ graphique 1.1 - NOUVEAU rÃ©sultat]
    toujours afficher graphique 
    
    Interpretertation...
````
    
    [ERROR] INTERDIT :
````
    [Code 1 â†’ Tableau 1.1]
    [Code 1 BIS (mÃªme chose) â†’ Tableau 1.1 dupliquÃ©]
    le code ne doit jamais etre afficher dans le rapport
````
    [ERROR] CE QUI APPARAÃT ACTUELLEMENT (ERREUR) :
    le code ne doit jamais etre afficher dans le rapport
    ```
    ### 2.1. Analyse

    ```python
    import pandas as pd
    chapitre = 2
    # ... code ...
    ```

    **Tableau 2.1 : RÃ©sultats**
    ```

    [OK] CE QUI DOIT APPARAÃTRE (CORRECT) :
    ```
    ### 2.1. Analyse

    **Tableau 2.1 : RÃ©sultats**

    | Variable | Valeur |
    |----------|--------|
    | CA 2015  | 92774  |

    L'analyse rÃ©vÃ¨le...
    ```

    ğŸ”´ DONC :
    - N'Ã©cris JAMAIS "Voici le code Python..." ou "Le code suivant..."
    - N'explique PAS ton code avant de l'Ã©crire
    - Ã‰cris DIRECTEMENT le code, il sera exÃ©cutÃ© et supprimÃ©
    - Seuls les print() et plt.show() gÃ©nÃ©reront du contenu visible

    ğŸ“‹ SECTIONS Ã€ COUVRIR :

    """
        
        # Ajouter sections Ã  couvrir
        for i, section in enumerate(chapter.sections, 1):
            prompt += f"""
    {chapter.number}.{i}. {section['titre']}
    Analyses : {', '.join(section['analyses'])}

    """
        
        prompt += f"""

    ğŸ“Œ FORMAT ATTENDU :
    - Structure Markdown (## pour chapitre, ### pour sections)
    - Commencer par : ## {chapter.number}. {chapter.title}
    - Ton acadÃ©mique mais accessible
    - Chiffres prÃ©cis + interprÃ©tation


    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘ SECTION 3 : TOP 10 RÃˆGLES CRITIQUES (PAR ORDRE D'IMPORTANCE)                â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    Lisez TOUTES ces rÃ¨gles avant de commencer. Elles sont classÃ©es par importance.
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #0 : CODE = INVISIBLE (LA RÃˆGLE SUPRÃŠME)                      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ğŸ¯ PRINCIPE FONDAMENTAL :
    Le lecteur du rapport NE DOIT JAMAIS voir de code Python.
    Le code est un OUTIL D'ANALYSE, pas du contenu de rapport.

    [ERROR] CE QUI NE DOIT JAMAIS APPARAÃTRE DANS LE RAPPORT :
````python
    import pandas as pd
    df = pd.read_excel(...)
    # ... tout code Python ...
````

    [OK] CE QUI DOIT APPARAÃTRE :
    - Les tableaux de rÃ©sultats
    - Les graphiques
    - Les interprÃ©tations en prose
    - Les insights business

    ğŸ”§ COMMENT Ã‡A MARCHE :
    1. Vous Ã©crivez le code entre ```python et ```
    2. Le systÃ¨me l'EXÃ‰CUTE dans un sandbox
    3. Le systÃ¨me SUPPRIME le code du rapport
    4. Le systÃ¨me GARDE uniquement les rÃ©sultats (print, graphiques)

    [WARNING] DONC :
    - N'expliquez JAMAIS votre code au lecteur
    - Ne dites JAMAIS "Voici le code..." ou "Le code suivant..."
    - Ã‰crivez comme si le code n'existait pas pour le lecteur
    - Seuls les RÃ‰SULTATS comptent

    ğŸ“– STYLE D'Ã‰CRITURE CORRECT :
````
    L'analyse de la structure de financement rÃ©vÃ¨le des insights clÃ©s.

    **Tableau 1.1 : CorrÃ©lation Fonds Propres - CA 2015**
    
    | Variable 1 | Variable 2 | CorrÃ©lation |
    |------------|------------|-------------|
    | Fonds propres | CA 2015 | 0.04 |

    Cette faible corrÃ©lation (0.04) suggÃ¨re que...
````

    [ERROR] CE QU'IL NE FAUT PAS Ã‰CRIRE :
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #1 : INITIALISATION OBLIGATOIRE (LA PLUS IMPORTANTE)               â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    [WARNING] FORMAT STRICT DES BALISES DE CODE :

    TOUJOURS utiliser ce format EXACT :
    ```python
    [votre code ici]
    ```

    [ERROR] FORMATS INTERDITS :
    ~~~python  (tildes)
    ```py      (abrÃ©viation)
    `python    (simple backtick)

    [OK] FORMAT OBLIGATOIRE :
    ```python
    import pandas as pd
    ...
    ```

    CHAQUE bloc ```python``` DOIT commencer par :

    ```python
    import pandas as pd
    import numpy as np
    import matplotlib.pyplot as plt
    import seaborn as sns

    chapitre = {chapter.number}
    tableau_counter = 1
    figure_counter = 1

    plt.style.use('seaborn-v0_8-darkgrid')
    sns.set_palette("husl")
    ```

    [ERROR] SANS CE BLOC â†’ NameError: name 'chapitre' is not defined
    [OK] TOUJOURS copier ce bloc au dÃ©but de CHAQUE code
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #1.5 : PAS DE CONFIGURATION E2B DANS LE CODE                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    [WARNING] RÃˆGLE CRITIQUE : FORMAT DU CODE PYTHON
    
    [OK] CORRECT - Chaque bloc Python doit commencer ainsi:
````python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Votre code d'analyse ici
````

    [ERROR] INTERDIT ABSOLU:
    - NE JAMAIS Ã©crire: import os; os.environ[...]
    - NE JAMAIS ajouter de configuration d'environnement
    - NE JAMAIS mettre de code avant les imports

    Le systÃ¨me gÃ¨re automatiquement l'environnement d'exÃ©cution.
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #2 : INTERPRÃ‰TATION IMMÃ‰DIATE (CAUSE #1 DE REJET)                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ORDRE STRICT pour chaque analyse :
    1ï¸âƒ£ Introduction (1-2 phrases)
    2ï¸âƒ£ Code Python â†’ RÃ©sultat
    3ï¸âƒ£ InterprÃ©tation (2-4 phrases en prose)
    4ï¸âƒ£ Transition (1 phrase)

    [ERROR] INTERDIT : 2+ tableaux/graphiques sans interprÃ©tation entre eux
    [OK] OBLIGATOIRE : 1 Ã©lÃ©ment = 1 interprÃ©tation IMMÃ‰DIATE

    EXEMPLE CORRECT :
    ```
    Examinons la rÃ©partition gÃ©ographique.

    [Code â†’ Tableau]

    Les donnÃ©es rÃ©vÃ¨lent une concentration dans le LITTORAL (37%)...
    Cette prÃ©dominance reflÃ¨te le dynamisme Ã©conomique cÃ´tier.

    Analysons maintenant le type d'entreprise.

    [Code â†’ Graphique]

    Le graphique montre la dominance des TPE (49%)...
    ```

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #3 : GUILLEMETS DANS LES F-STRINGS (CAUSE #1 D'ERREURS)            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    [ERROR] ERREUR FRÃ‰QUENTE :
    print(f"Analyse "Chiffre d'affaire"")  # SyntaxError !

    [OK] SOLUTION :
    print(f"Analyse 'Chiffre d\\'affaire'")  # Guillemets simples + Ã©chappement

    ğŸ“Œ RÃˆGLE : F-string = " extÃ©rieur, ' intÃ©rieur

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #4 : TRY-EXCEPT OBLIGATOIRE (ZÃ‰RO ERREUR DANS RAPPORT)             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    TOUT code graphique DOIT Ãªtre dans try-except :

    ```python
    try:
        # Graphique
        fig, ax = plt.subplots()
        # ... code ...
        plt.show()
        print(f"**Graphique {{chapitre}}.{{figure_counter}} : Titre**")
        figure_counter += 1
    except:
        # Fallback tableau
        print(f"**Tableau {{chapitre}}.{{tableau_counter}} : DonnÃ©es**")
        # ... tableau simple ...
        tableau_counter += 1
    ```

    [ERROR] INTERDIT : Afficher erreur dans le rapport
    [OK] OBLIGATOIRE : Fallback pour CHAQUE graphique

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #5 : VARIABLES ENCODÃ‰ES (ERREUR FRÃ‰QUENTE)                         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    AVANT calcul moyenne, VÃ‰RIFIER :

    ```python
    if df['colonne'].nunique() < 10:
        # EncodÃ©e â†’ distribution seulement
        print("Distribution :")
        # ... frÃ©quences ...
    else:
        # Continue â†’ statistiques
        print(f"Moyenne : {{df['colonne'].mean():.2f}}")
    ```

    [ERROR] ERREUR : Moyenne sur Age encodÃ© (1,2,3) â†’ "2.5 ans" absurde !
    [OK] CORRECT : VÃ©rifier d'abord

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #6 : NUMÃ‰ROTATION SYSTÃ‰MATIQUE                                     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Format : **Tableau/Graphique {{chapitre}}.{{counter}} : Titre**

    ```python
    print(f"**Tableau {{chapitre}}.{{tableau_counter}} : Titre**")
    tableau_counter += 1
    ```

    [ERROR] INTERDIT : Oublier numÃ©rotation
    [OK] OBLIGATOIRE : NumÃ©ro sÃ©quentiel

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #7 : Ã‰QUILIBRE TABLEAUX/GRAPHIQUES (40% GRAPHIQUES MIN)            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    CONVERSIONS OBLIGATOIRES :
    - Distribution (>5 cat) â†’ GRAPHIQUE barres
    - CorrÃ©lations â†’ HEATMAP
    - Moyennes/groupe â†’ GRAPHIQUE barres
    - Ã‰volutions â†’ GRAPHIQUE ligne

    [ERROR] INTERDIT : Chapitre avec que des tableaux
    [OK] OBJECTIF : 40% minimum de graphiques

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #8 : APOSTROPHES & CARACTÃˆRES SPÃ‰CIAUX                             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Colonnes avec apostrophes :

    [ERROR] ERREUR : cols = ['Nombre d'annÃ©e']  # SyntaxError
    [OK] SOLUTION 1 : cols = ["Nombre d'annÃ©e"]  # Guillemets doubles
    [OK] SOLUTION 2 : cols = ['Nombre d\\'annÃ©e']  # Ã‰chapper

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #9 : CONVERSION FLOAT AVANT FORMATAGE                              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    TOUJOURS convertir Pandas â†’ float :

    [ERROR] ERREUR : print(f"Val : {{df.loc[0, 'col']:.2f}}")  # TypeError
    [OK] CORRECT : val = float(df.loc[0, 'col'])
                print(f"Val : {{val:.2f}}")

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #10 : ORDRE STRICT GRAPHIQUES                                      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ORDRE NON-NÃ‰GOCIABLE :
    1ï¸âƒ£ Code Python
    2ï¸âƒ£ plt.show()
    3ï¸âƒ£ print(f"**Graphique...**")  â† APRÃˆS plt.show() !
    4ï¸âƒ£ InterprÃ©tation

    [ERROR] INTERDIT : Titre avant plt.show()
    [OK] OBLIGATOIRE : Titre TOUJOURS aprÃ¨s plt.show()

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #11 : JAMAIS DE TABLEAUX CONSÃ‰CUTIFS (ULTRA-CRITIQUE)              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    [ERROR] INTERDIT ABSOLU :
    ```
    Tableau 2.1 : Stats Age
    Tableau 2.2 : Stats DiplÃ´me  â† SANS interprÃ©tation du 2.1 !
    ```

    [OK] OBLIGATOIRE :
    ```
    Tableau 2.1 : Stats Age

    [INTERPRÃ‰TATION IMMÃ‰DIATE - minimum 2 phrases]
    L'analyse rÃ©vÃ¨le que... Les donnÃ©es montrent...

    Tableau 2.2 : Stats DiplÃ´me

    [INTERPRÃ‰TATION IMMÃ‰DIATE - minimum 2 phrases]
    On observe que... Cette distribution suggÃ¨re...
    ```

    ğŸ“Œ RÃˆGLE D'OR : 1 tableau = 1 interprÃ©tation AVANT le tableau suivant

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”´ RÃˆGLE #12 : VALEURS MANQUANTES OBLIGATOIRES (SI > 0%)                    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Tous les codes sont des prompt que vous devez adaptez pour Ã©viter des erreurs comme count is not define ou encore missing_count is not define
    SI des valeurs manquantes existent, OBLIGATOIRE :

    1ï¸âƒ£ CRÃ‰ER une section dÃ©diÃ©e : "QualitÃ© des donnÃ©es"

    2ï¸âƒ£ ANALYSER CHAQUE variable avec valeurs manquantes :

    ```python
    # Identifier colonnes avec valeurs manquantes
    missing = df.isnull().sum()
    missing = missing[missing > 0].sort_values(ascending=False)

    print(f"**Tableau {{chapitre}}.{{tableau_counter}} : Valeurs Manquantes**")
    print()
    print("| Variable | Nombre | % |")
    print("|----------|--------|---|")
    for col, count in missing.items():
        pct = count / len(df) * 100
        print(f"| {{{{col}}}} | {{{{missing_count}}}} | {{{{pct:.2f}}}}% |")
    tableau_counter += 1
    ```

    3ï¸âƒ£ INTERPRÃ‰TER :
    - Quelles variables ?
    - Quel impact ?
    - StratÃ©gie de traitement ?

    [ERROR] INTERDIT : Mentionner valeurs manquantes sans les analyser
    [OK] OBLIGATOIRE : Section complÃ¨te si valeurs manquantes > 0%


    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘ SECTION 4 : TEMPLATES CODE PRÃŠTS Ã€ L'EMPLOI                                 â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    Copiez-collez ces templates selon vos besoins.

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ“ TEMPLATE 1 : Distribution avec fallback                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ```python
    try:
        # Graphique
        fig, ax = plt.subplots(figsize=(10, 6))
        df['variable'].value_counts().plot(kind='bar', ax=ax)
        ax.set_title("Distribution")
        ax.tick_params(axis='x', labelrotation=45)
        for label in ax.get_xticklabels():
            label.set_ha('right')
        plt.tight_layout()
        plt.show()
        
        print(f"**Graphique {{chapitre}}.{{figure_counter}} : Distribution**")
        figure_counter += 1

    except:
        # Tableau fallback
        counts = df['variable'].value_counts()
        print(f"**Tableau {{chapitre}}.{{tableau_counter}} : Distribution**")
        print()
        print("| CatÃ©gorie | Effectif | % |")
        print("|-----------|----------|---|")
        for cat, count in counts.items():
            pct = count / len(df) * 100
            print(f"| {{cat}} | {{count}} | {{pct:.1f}}% |")
        tableau_counter += 1
    ```

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ“ TEMPLATE 2 : CorrÃ©lations (heatmap)                                      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ```python
    try:
        fig, ax = plt.subplots(figsize=(12, 10))
        sns.heatmap(df.corr(), annot=True, fmt='.2f', cmap='coolwarm', ax=ax)
        plt.title("CorrÃ©lations")
        plt.tight_layout()
        plt.show()
        
        print(f"**Graphique {{chapitre}}.{{figure_counter}} : CorrÃ©lations**")
        figure_counter += 1

    except:
        print(f"**Tableau {{chapitre}}.{{tableau_counter}} : CorrÃ©lations**")
        # ... tableau corrÃ©lations ...
        tableau_counter += 1
    ```

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ“ TEMPLATE 3 : Variable encodÃ©e                                            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ```python
    col = 'Age du promoteur'

    if df[col].nunique() < 10:
        # EncodÃ©e
        print(f"**Distribution de {{col}} :**")
        print()
        print("| CatÃ©gorie | Effectif | % |")
        print("|-----------|----------|---|")
        freq = df[col].value_counts().sort_index()
        for value, count in freq.items():
            pct = count / len(df) * 100
            print(f"| Tranche {{int(value)}} | {{count}} | {{pct:.1f}}% |")
    else:
        # Continue
        mean_val = float(df[col].mean())
        print(f"Moyenne : {{mean_val:.2f}}")
    ```

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ“ TEMPLATE 4 : Analyse valeurs manquantes (OBLIGATOIRE si NaN > 0)         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ```python
    # Identifier valeurs manquantes
    Exemple de code Ã  adapter selon le contexte :
    missing = df.isnull().sum()
    missing = missing[missing > 0].sort_values(ascending=False)

    if len(missing) > 0:
        print(f"**Tableau {{chapitre}}.{{tableau_counter}} : Valeurs Manquantes par Variable**")
        print()
        print("| Variable | Nombre | % | Impact |")
        print("|----------|--------|---|--------|")
        
        for col, count in missing.items():
            pct = count / len(df) * 100
            impact = "Faible" if pct < 1 else "ModÃ©rÃ©" if pct < 5 else "Ã‰levÃ©"
            print(f"| {{col}} | {{count}} | {{pct:.2f}}% | {{impact}} |")
        
        print()
        tableau_counter += 1
        
        # INTERPRÃ‰TATION OBLIGATOIRE
        print(f\"\"\"L'analyse des valeurs manquantes rÃ©vÃ¨le que {{len(missing)}} variables 
    sont concernÃ©es. La variable '{{missing.index[0]}}' prÃ©sente le taux le plus 
    Ã©levÃ© avec {{missing.iloc[0] / len(df) * 100:.2f}}% de donnÃ©es manquantes. 
    Ces valeurs manquantes nÃ©cessitent un traitement appropriÃ© selon leur nature 
    et leur proportion avant toute modÃ©lisation.\"\"\")
    ```


    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘ SECTION 5 : CHECKLIST AVANT ENVOI                                           â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    Avant de finaliser, VÃ‰RIFIEZ :

    â˜ Initialisation (chapitre, counters) au dÃ©but de CHAQUE code
    â˜ InterprÃ©tation IMMÃ‰DIATE aprÃ¨s CHAQUE tableau/graphique
    â˜ JAMAIS 2 tableaux ou 2 graphiques consÃ©cutifs sans interprÃ©tation
    â˜ Guillemets simples ' dans f-strings (pas ")
    â˜ Try-except autour de TOUS les graphiques
    â˜ Variables encodÃ©es vÃ©rifiÃ©es avant moyenne
    â˜ NumÃ©rotation sÃ©quentielle tableaux/graphiques
    â˜ 40% minimum de graphiques
    â˜ Apostrophes Ã©chappÃ©es
    â˜ Conversion float avant formatage
    â˜ plt.show() AVANT print("**Graphique...**")
    â˜ Section "Valeurs Manquantes" si des NaN existent
    â˜ Pas de duplication de code ou de tableaux
    â˜ Chaque analyse est unique et progressive
    â˜ Si un rÃ©sultat est dÃ©jÃ  montrÃ©, passer Ã  l'analyse suivante



    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘ ğŸ¯ RÃˆGLES ADDITIONNELLES IMPORTANTES                                        â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    ğŸ“Œ SÃ‰LECTION VARIABLES :
    - Max 10 pour stats descriptives
    - Max 5 pour corrÃ©lations
    - Exclure ID, index, Unnamed

    ğŸ“Œ TABLEAUX MARKDOWN :
    - Chaque ligne DOIT commencer ET finir par |
    - Format : | Col1 | Col2 |

    ğŸ“Œ LABELS VARIABLES ENCODÃ‰ES :
    - Pas "Tranche 1, Tranche 2"
    - Utiliser labels contextuels (ex: "< 25 ans", "25-35 ans")

    ğŸ“Œ INTERDICTIONS ABSOLUES :
    - [ERROR] print(df.info())
    - [ERROR] df.to_markdown() ou .to_markdown() (utiliser .to_string() Ã  la place)
    - [ERROR] pd.read_csv() ou pd.read_excel() (df dÃ©jÃ  chargÃ© automatiquement)
    - [ERROR] import os; os.environ[...] (configuration systÃ¨me interdite)
    - [ERROR] Statsmodels (utiliser scipy.stats)
    - [ERROR] CrÃ©er des variables intermÃ©diaires (df_kpi, df_temp, etc.) utilisÃ©es dans un autre bloc
    - [ERROR] Blocs try: vides (toujours mettre au moins 'pass' dans le try)
    - [ERROR] ParamÃ¨tres matplotlib abrÃ©gÃ©s (ha=, va=) - utiliser noms complets
    - [ERROR] Plusieurs Ã©lÃ©ments visuels sans interprÃ©tation
    - [ERROR] Tableaux consÃ©cutifs sans interprÃ©tation entre eux
    - [ERROR] Mentionner valeurs manquantes sans les analyser
    - [ERROR] Ã‰crire "Voici le code..." ou expliquer le code avant de l'Ã©crire
    - [ERROR] Dire "Le code suivant..." ou "Nous allons exÃ©cuter..."
    ğŸ“Œ COMMENT Ã‰CRIRE :
    [ERROR] MAUVAIS :

    ```
    Voici le code Python pour analyser les donnÃ©es :

    ```python
    import pandas as pd
    ...
    ```

    Les rÃ©sultats montrent...
    ```

    [OK] CORRECT :
    ```
    Analysons la distribution des entreprises par rÃ©gion.

    ```python
    # Pour afficher un tableau Markdown
    print(f"**Tableau {{chapitre}}.{{tableau_counter}} : Distribution par rÃ©gion**")
    print()
    print("| RÃ©gion | Nombre | % |")
    print("|--------|--------|---|")
    for region, count in df['Region'].value_counts().items():
        pct = count / len(df) * 100
        print(f"| {{region}} | {{count}} | {{pct:.1f}}% |")
    tableau_counter += 1
    ```

    L'analyse rÃ©vÃ¨le une forte concentration dans la rÃ©gion OUEST...
    ```

    [ERROR] NE PAS UTILISER :
    ```python
    # INTERDIT - tabulate non disponible
    print(df.to_markdown())
    ```

    [OK] UTILISER Ã€ LA PLACE :
    ```python
    # MÃ©thode 1: Tableaux manuels (recommandÃ© pour contrÃ´le)
    print("| Col1 | Col2 |")
    print("|------|------|")
    print(f"| {{val1}} | {{val2}} |")
    
    # MÃ©thode 2: to_string() pour tableaux simples
    print(df.head().to_string())
    ```

    â†’ Le code sera EXÃ‰CUTÃ‰ et SUPPRIMÃ‰, seuls les rÃ©sultats restent !

    [WARNING] RÃˆGLE CRITIQUE : INDÃ‰PENDANCE DES BLOCS DE CODE
    
    Chaque bloc ```python...``` est exÃ©cutÃ© INDÃ‰PENDAMMENT.
    Les variables crÃ©Ã©es dans un bloc N'EXISTENT PAS dans le bloc suivant !
    
    [ERROR] INTERDIT (ne fonctionnera PAS) :
    ```python
    # Bloc 1
    df_kpi = df.copy()
    df_kpi['CA_per_emp'] = df_kpi['CA'] / df_kpi['Effectifs']
    ```
    
    Plus tard dans une autre section...
    
    ```python
    # Bloc 2 - [ERROR] ERREUR: df_kpi n'existe plus !
    result = df_kpi.groupby('Region').mean()
    ```
    
    [OK] CORRECT (tout dans UN SEUL bloc) :
    ```python
    # CrÃ©er, calculer ET utiliser dans le MÃŠME bloc
    ca_per_emp = df['CA'] / df['Effectifs'].replace(0, 1)  # Ã‰viter division par 0
    result = ca_per_emp.groupby(df['Region']).mean()
    
    print("**Tableau X : CA par employÃ© par rÃ©gion**")
    for region, value in result.items():
        print(f"| {{region}} | {{value:.0f}} |")
    ```
    
    ğŸ’¡ RÃˆGLE D'OR : 
    - Utilisez TOUJOURS 'df' directement
    - NE crÃ©ez PAS df_kpi, df_temp, df_filtered, etc.
    - Faites tous les calculs dans UN SEUL bloc de code

    [DATA] RÃˆGLES MATPLOTLIB :
    
    [ERROR] INTERDIT (paramÃ¨tres abrÃ©gÃ©s) :
    ```python
    plt.xticks(rotation=45, ha='center')  # [ERROR] 'ha' non reconnu
    plt.yticks(va='top')                   # [ERROR] 'va' non reconnu
    ```
    
    [OK] CORRECT (noms complets) :
    ```python
    plt.xticks(rotation=45, horizontalalignment='center')  # [OK]
    plt.yticks(verticalalignment='top')                    # [OK]
    ```
    
    ğŸ”§ BLOCS TRY/EXCEPT :
    
    [ERROR] INTERDIT (try vide) :
    ```python
    try:
    except Exception:
        pass
    ```
    
    [OK] CORRECT :
    ```python
    try:
        # Code ici
        plt.savefig('graph.png')
    except Exception as e:
        print(f"Erreur: {{e}}")
    ```

    ğŸ“Œ OBLIGATIONS :
    - InterprÃ©tation APRÃˆS CHAQUE tableau/graphique
    - Section "Valeurs Manquantes" si NaN > 0%
    - Minimum 2 phrases par interprÃ©tation
    - RÃ©fÃ©rences correctes (tableau vs graphique)

    Autres promptes a prendre en compte

    [OK] EXEMPLE  : Graphiques avec dÃ©tection automatique

    ```python
    import matplotlib.pyplot as plt
    import seaborn as sns

    # DÃ©tecter automatiquement les colonnes numÃ©riques
    numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
    exclude_keywords = ['id', 'index', 'unnamed', 'key', 'code', 'numero']
    numeric_cols = [col for col in numeric_cols 
                    if not any(kw in col.lower() for kw in exclude_keywords)]

    # CrÃ©er un histogramme avec la premiÃ¨re colonne numÃ©rique (non encodÃ©e)
    if numeric_cols:
        # Trouver premiÃ¨re colonne avec > 10 valeurs uniques
        for col in numeric_cols:
            if df[col].nunique() > 10:
                plt.figure(figsize=(10, 6))
                sns.histplot(df[col], bins=20, kde=True)
                plt.title(f'Distribution de {{col}}')
                plt.xlabel(col)
                plt.ylabel('FrÃ©quence')
                plt.show()
                break
    ```

    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    6. ORGANISATION NARRATIVE (RAPPORT PROFESSIONNEL)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    Structure requise pour CHAQUE analyse :

    1ï¸âƒ£ Introduction contextuelle (1-2 phrases)
    2ï¸âƒ£ [Code Python â†’ Ã‰lÃ©ment visuel (tableau OU graphique)]
    3ï¸âƒ£ InterprÃ©tation immÃ©diate en prose (2-4 phrases, SANS marqueur)
    4ï¸âƒ£ Implications/discussion (1-2 phrases)
    5ï¸âƒ£ Transition vers l'analyse suivante (1 phrase)
    6ï¸âƒ£ [RÃ©pÃ©ter pour chaque Ã©lÃ©ment visuel]

    ğŸ”´ CARACTÃ‰RISTIQUES D'UN RAPPORT PROFESSIONNEL :

    [OK] CE QU'ON VEUT :
    - Prose fluide et naturelle
    - Transitions entre les parties
    - InterprÃ©tation intÃ©grÃ©e au texte
    - Ton analytique mais accessible
    - Style de publication scientifique
    - JAMAIS 2+ tableaux/graphiques sans interprÃ©tation entre eux

    [ERROR] CE QU'ON NE VEUT PAS :
    - **InterprÃ©tation :** ...
    - **Analyse :** ...
    - **Discussion :** ...
    - Bullet points pour les interprÃ©tations
    - Style "devoir scolaire"
    - Plusieurs Ã©lÃ©ments visuels consÃ©cutifs sans texte

    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    7. RÃˆGLES DE CONCISION
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    [WARNING] Ã‰VITER LA VERBOSITÃ‰ EXCESSIVE :

    [ERROR] TROP LONG :
    "L'analyse approfondie des donnÃ©es collectÃ©es rÃ©vÃ¨le de maniÃ¨re significative et 
    notable que la distribution observÃ©e des valeurs au sein de l'Ã©chantillon Ã©tudiÃ© 
    prÃ©sente une configuration particuliÃ¨re qui mÃ©rite une attention toute particuliÃ¨re..."

    [OK] CONCIS ET PRÃ‰CIS :
    "L'analyse rÃ©vÃ¨le une distribution asymÃ©trique, avec 75% des valeurs concentrÃ©es 
    entre 20 et 40 ans. Cette concentration suggÃ¨re une population jeune, cohÃ©rente 
    avec le contexte urbain."

    RÃˆGLES :
    - Phrases de 15-25 mots maximum
    - Ã‰viter les rÃ©pÃ©titions ("significatif", "notable", "important")
    - Aller droit au fait
    - Chiffres prÃ©cis plutÃ´t que qualificatifs vagues

    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    8. ANALYSES STATISTIQUES
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    - Variables disponibles : {{self._get_available_variables()}}
    - Utiliser pandas pour les calculs
    - InterprÃ©ter les rÃ©sultats statistiques
    - TOUJOURS expliquer ce que signifient les chiffres
    - VÃ©rifier si variables encodÃ©es avant calculs de moyennes/Ã©carts-types

    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    9. Ã€ Ã‰VITER ABSOLUMENT
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    [ERROR] RÃ©pÃ©ter les analyses des chapitres prÃ©cÃ©dents
    [ERROR] Utiliser les mÃªmes graphiques qu'avant
    [ERROR] ÃŠtre trop technique sans vulgariser
    [ERROR] EnchaÃ®ner 2+ tableaux/graphiques sans interprÃ©tation entre eux
    [ERROR] Dire "graphique ci-dessus" quand c'est un tableau
    [ERROR] Dire "tableau ci-dessus" quand c'est un graphique
    [ERROR] Utiliser des marqueurs scolaires (**InterprÃ©tation:**, **Analyse:**)
    [ERROR] Calculer des moyennes sur des variables encodÃ©es

    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    DONNÃ‰ES :
    Le fichier de donnÃ©es est disponible Ã  : {{self.csv_path}}

    GÃ©nÃ¨re maintenant le Chapitre {chapter.number} en Markdown complet en respectant 
    SCRUPULEUSEMENT toutes ces rÃ¨gles, en particulier :
    1. InterprÃ©tation IMMÃ‰DIATE aprÃ¨s CHAQUE tableau/graphique
    2. VÃ©rification des variables encodÃ©es
    3. RÃ©fÃ©rences correctes (tableau vs graphique)
    4. Gestion robuste des erreurs (KeyError, TypeError)
    5. Conversion float() avant formatage
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ğŸ”´ Rappel:RÃˆGLE Dâ€™ORDRE ABSOLUE DES GRAPHIQUES (NON NÃ‰GOCIABLE)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    POUR CHAQUE GRAPHIQUE, Lâ€™ORDRE DE SORTIE DOIT ÃŠTRE STRICTEMENT :

    1ï¸âƒ£ CODE PYTHON AVEC plt.show()  
    2ï¸âƒ£ LIGNE DE TITRE DU GRAPHIQUE (Graphique X.Y : â€¦)  
    3ï¸âƒ£ PARAGRAPHE Dâ€™INTERPRÃ‰TATION IMMÃ‰DIAT (2â€“4 phrases)

    [WARNING] INTERDICTIONS FORMELLES :
    [ERROR] Ne JAMAIS Ã©crire le titre du graphique AVANT le code
    [ERROR] Ne JAMAIS Ã©crire lâ€™interprÃ©tation AVANT plt.show()
    [ERROR] Ne JAMAIS Ã©crire â€œLe graphique ci-dessusâ€¦â€ AVANT que le graphique soit affichÃ©

    [OK] Le titre du graphique DOIT Ãªtre imprimÃ© JUSTE APRÃˆS plt.show() via print().

    ```markdown
    ğŸ”´ RÃˆGLE LEXICALE STRICTE :

    Lâ€™expression â€œLe graphique ci-dessusâ€ est AUTORISÃ‰E UNIQUEMENT :
    [OK] aprÃ¨s que le graphique a Ã©tÃ© affichÃ© (plt.show())
    [OK] aprÃ¨s que la ligne â€œGraphique X.Y : â€¦â€ a Ã©tÃ© imprimÃ©e

    [ERROR] INTERDIT dâ€™utiliser cette expression avant le code ou avant le titre.```

    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘ ğŸš€ GÃ‰NÃ‰REZ MAINTENANT LE CHAPITRE !                                         â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    DonnÃ©es : {self.csv_path}

    Suivez scrupuleusement les 10 RÃˆGLES CRITIQUES.
    En cas de doute, relisez la section correspondante.

    BON TRAVAIL !
    """
        
        # Remplacer variables
        prompt = prompt.replace("{chapter.number}", str(chapter.number))
        prompt = prompt.replace("{chapter.title}", chapter.title)
        
        return prompt
    
    def _get_available_variables(self) -> str:
        """Retourne les variables disponibles dans le fichier"""
        try:
            import pandas as pd
            import os
            
            file_extension = os.path.splitext(self.csv_path)[1].lower()
            
            if file_extension in ['.xlsx', '.xls']:
                df_temp = pd.read_excel(self.csv_path)
            else:
                df_temp = pd.read_csv(self.csv_path)
            
            return ", ".join(df_temp.columns.tolist()[:10]) + ("..." if len(df_temp.columns) > 10 else "")
        except:
            return "(colonnes non listÃ©es)"
    
    def _generate_with_ai(self, prompt: str, task_type: str = "default") -> str:
        """
        GÃ©nÃ¨re le contenu avec l'IA (Gemini ou Claude en backup)
        
        Args:
            prompt: Le prompt
            task_type: Type de tÃ¢che pour sÃ©lectionner le meilleur modÃ¨le
        
        NOUVEAUTÃ‰: Support multi-modÃ¨les + fallback automatique + spÃ©cialisation
        """
        import os
        
        # VÃ©rifier si on force l'utilisation de Claude
        use_claude = os.getenv("USE_CLAUDE", "false").lower() == "true"
        
        if use_claude:
            logger.info("Using Claude API (forced via USE_CLAUDE)")
            return self._generate_with_claude(prompt)
        
        # Essayer Gemini d'abord avec le modÃ¨le spÃ©cialisÃ©
        try:
            return self._generate_with_gemini(prompt, task_type=task_type)
        
        except Exception as e:
            error_msg = str(e)
            
            # Si quota dÃ©passÃ©, essayer Claude en backup
            if "429" in error_msg or "quota" in error_msg.lower():
                logger.warning(f"Gemini quota exceeded, falling back to Claude: {error_msg}")
                
                try:
                    return self._generate_with_claude(prompt)
                except Exception as claude_error:
                    logger.error(f"Claude also failed: {claude_error}")
                    raise Exception(f"Both Gemini and Claude failed. Gemini: {error_msg}, Claude: {claude_error}")
            
            # Autre erreur, relancer
            raise
    
    def _generate_with_gemini(self, prompt: str, task_type: str = "default") -> str:
        """
        GÃ©nÃ¨re avec Gemini en utilisant un modÃ¨le spÃ©cialisÃ© selon la tÃ¢che
        
        Args:
            prompt: Le prompt Ã  envoyer
            task_type: Type de tÃ¢che ("code", "writing", "analysis", "plan", "default")
        """
        import google.generativeai as genai
        import os
        
        genai.configure(api_key=os.getenv("GMINI_API_KEY"))
        
        # SÃ©lection du modÃ¨le selon le type de tÃ¢che
        model_map = {
            "code": os.getenv("GEMINI_MODEL_CODE", "gemini-2.5-flash"),
            "writing": os.getenv("GEMINI_MODEL_WRITING", "gemini-2.5-pro"),
            "analysis": os.getenv("GEMINI_MODEL_ANALYSIS", "gemini-2.5-pro"),
            "plan": os.getenv("GEMINI_MODEL_PLAN", "gemini-2.5-flash"),
            "default": os.getenv("GEMINI_MODEL", "gemini-1.5-flash")
        }
        
        model_name = model_map.get(task_type, model_map["default"])
        
        logger.info(f"Using Gemini model: {model_name} for task: {task_type}")
        
        model = genai.GenerativeModel(model_name)
        
        response = model.generate_content(prompt)
        
        return response.text
    
    def _generate_with_claude(self, prompt: str) -> str:
        """GÃ©nÃ¨re avec Claude (backup si Gemini quota dÃ©passÃ©)"""
        import os
        
        try:
            from anthropic import Anthropic
        except ImportError:
            raise ImportError("Package 'anthropic' requis. Installez avec: pip install anthropic")
        
        client = Anthropic(api_key=os.getenv("ANTHROPIC_API_KEY"))
        
        logger.info("Using Claude API (claude-3-5-sonnet)")
        
        response = client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=4000,
            messages=[
                {"role": "user", "content": prompt}
            ]
        )
        
        return response.content[0].text
    def _execute_code_blocks(self, content: str) -> str:
            """
            ExÃ©cute les blocs de code Python. 
            Version stabilisÃ©e : respecte l'indentation interne des blocs try/if.
            """
            import re
            import os
            import base64
            from e2b_session_manager import execute_python_code

            pattern = r'[ \t]*```python\n([\s\S]*?)\n[ \t]*```'
            matches = list(re.finditer(pattern, content))
            if not matches: return content

            modified_content = content
            # PrÃ©paration du chargement des donnÃ©es
            file_extension = os.path.splitext(self.csv_path)[1].lower()
            try:
                if file_extension in ['.xlsx', '.xls']:
                    with open(self.csv_path, 'rb') as f:
                        file_base64 = base64.b64encode(f.read()).decode('utf-8')
                    data_loading_code = f"import pandas as pd\nimport io, base64\ndf = pd.read_excel(io.BytesIO(base64.b64decode('{file_base64}')))"
                else:
                    with open(self.csv_path, 'r', encoding='utf-8', errors='replace') as f:
                        csv_text = f.read().replace("'''", '"""')
                    data_loading_code = f"import pandas as pd\nimport io\ndf = pd.read_csv(io.StringIO('''{csv_text}'''))"
            except Exception as e:
                data_loading_code = f"# Erreur : {str(e)}"

            for match in reversed(matches):
                start, end = match.span()
                raw_code = match.group(1)
                
                # --- NETTOYAGE INTELLIGENT DE L'INDENTATION ---
                lines = raw_code.split('\n')
                # On retire uniquement l'indentation commune la plus petite (marge Markdown)
                # sans toucher Ã  l'indentation relative des blocs internes (try/except/if)
                non_empty_lines = [l for l in lines if l.strip()]
                if non_empty_lines:
                    margin = min(len(l) - len(l.lstrip()) for l in non_empty_lines)
                    cleaned_lines = [l[margin:] if len(l) >= margin else l.lstrip() for l in lines]
                else:
                    cleaned_lines = lines

                # Filtrage des lignes toxiques (pd.read_ et config E2B)
                final_code_lines = []
                for l in cleaned_lines:
                    if any(x in l for x in ['pd.read_', 'E2B_EVENTS_ADDRESS', 'os.environ']): continue
                    
                    # Remplacer .to_markdown() par .to_string() (tabulate non disponible dans E2B)
                    if '.to_markdown(' in l:
                        l = l.replace('.to_markdown(', '.to_string(')
                        logger.warning(f"Replaced .to_markdown() with .to_string() in line")
                    if 'to_markdown()' in l:
                        l = l.replace('to_markdown()', 'to_string()')
                        logger.warning(f"Replaced to_markdown() with to_string() in line")
                    
                    final_code_lines.append(l)
                
                final_code = "\n".join(final_code_lines)
                
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # NOUVELLES CORRECTIONS (Patch #3)
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                # Correction 1: ComplÃ©ter les blocs try vides
                lines = final_code.split('\n')
                fixed_lines = []
                for i, line in enumerate(lines):
                    fixed_lines.append(line)
                    if line.strip().endswith('try:') and i+1 < len(lines):
                        next_line = lines[i+1].strip()
                        if next_line.startswith('except'):
                            indent = len(line) - len(line.lstrip()) + 4
                            fixed_lines.append(' ' * indent + 'pass')
                            logger.warning("Added 'pass' in empty try block")
                
                final_code = '\n'.join(fixed_lines)
                
                # Correction 2: Remplacer variables non dÃ©finies par 'df'
                undefined_vars = ['df_kpi', 'df_clean_n_annee', 'df_filtered', 'df_temp', 'df_analysis', 'df_copy']
                for var in undefined_vars:
                    if var in final_code and f"{var} =" not in final_code and f"{var}=" not in final_code:
                        logger.warning(f"Variable '{var}' used but not defined - replacing with 'df'")
                        final_code = final_code.replace(var, 'df')
                
                # Correction 3: Remplacer paramÃ¨tres matplotlib abrÃ©gÃ©s
                #if 'ha=' in final_code:
                    #final_code = final_code.replace('ha=', 'horizontalalignment=')
                    #logger.warning("Replaced 'ha=' with 'horizontalalignment='")
               # if 'va=' in final_code:
                   # final_code = final_code.replace('va=', 'verticalalignment=')
                   # logger.warning("Replaced 'va=' with 'verticalalignment='")
                
                full_code = f"""import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import io
{data_loading_code}

chapitre = {getattr(self.get_current_chapter(), 'number', 1)}
tableau_counter = 1
figure_counter = 1
plt.style.use('seaborn-v0_8-darkgrid')

{final_code}

if plt.get_fignums():
    plt.show()
"""
                result = execute_python_code(self.user_id, full_code)
                
                result_section = ""
                if result['success']:
                    if result.get('output'):
                        # Ajout de sauts de ligne pour forcer le rendu Markdown des tableaux
                        result_section += f"\n\n{self._format_output_as_markdown(result['output'])}\n\n"
                    if result.get('charts'):
                        for chart_b64 in result['charts']:
                            result_section += f"\n![Graphique](data:image/png;base64,{chart_b64})\n"
                else:
                    result_section = f"\n> [WARNING] **Erreur d'analyse :** {result.get('error')}\n"

                modified_content = modified_content[:start] + result_section + modified_content[end:]
                
            return modified_content
        
    def _format_output_as_markdown(self, text: str) -> str:
        """Convertit les sorties texte en Markdown formatÃ© avec tableaux professionnels"""
        if not text or not text.strip():
            return ""
        
        # Si c'est un tableau de statistiques, le formater avec TableFormatter
        if 'count' in text and 'mean' in text:
            return self._convert_stats_to_markdown_table(text)
        
        # Sinon retourner le texte tel quel
        return text
    
    def _convert_stats_to_markdown_table(self, stats_text: str) -> str:
        """Convertit df.describe() en tableau Markdown professionnel avec TableFormatter"""
        try:
            import pandas as pd
            import io
            
            lines = [line.strip() for line in stats_text.strip().split('\n') if line.strip()]
            
            if len(lines) < 2:
                return stats_text
            
            # CrÃ©er un DataFrame Ã  partir du texte
            try:
                df_stats = pd.read_csv(io.StringIO(stats_text), sep=r'\s+')
                
                # Transposer pour avoir les statistiques en colonnes
                df_stats = df_stats.T
                
                # Utiliser TableFormatter
                formatter = TableFormatter(style='professional')
                
                return formatter.dataframe_to_markdown(
                    df_stats,
                    precision=2,
                    include_index=True
                )
            except Exception as parse_error:
                # Si le parsing Ã©choue, formater manuellement
                result = "\n**Statistiques descriptives :**\n\n"
                result += "| Statistique | Valeur |\n"
                result += "|-------------|--------|\n"
                
                for line in lines[1:]:  # Skip header
                    parts = line.split()
                    if len(parts) >= 2:
                        stat_name = parts[0]
                        stat_value = parts[1]
                        result += f"| {stat_name} | {stat_value} |\n"
                
                return result
        except Exception as e:
            logger.warning(f"Failed to format stats table: {e}")
            return stats_text
    
    def validate_chapter(self, chapter_number: str) -> bool:
        """
        Valide un chapitre
        
        Returns:
            True si chapitre trouvÃ© et validÃ©
        """
        chapter = self._find_chapter(chapter_number)
        
        if not chapter:
            return False
        
        if chapter.status != ChapterStatus.GENERATED:
            logger.warning(f"Cannot validate chapter {chapter_number}: status is {chapter.status}")
            return False
        
        chapter.status = ChapterStatus.VALIDATED
        chapter.validated_at = datetime.now()
        
        # Ajouter Ã  la mÃ©moire contextuelle
        add_chapter_to_memory(
            self.user_id,
            chapter.number,
            chapter.title,
            chapter.content,
            metadata={'csv_path': self.csv_path}
        )
        
        # Passer au chapitre suivant
        self.current_chapter_index += 1
        
        logger.info(f"Chapter {chapter_number} validated")
        
        return True
    
    def reject_chapter(self, chapter_number: str, reason: str = None) -> bool:
        """
        Rejette un chapitre (Ã  regÃ©nÃ©rer)
        
        Returns:
            True si chapitre trouvÃ© et rejetÃ©
        """
        chapter = self._find_chapter(chapter_number)
        
        if not chapter:
            return False
        
        chapter.status = ChapterStatus.REJECTED
        chapter.error_message = reason
        
        logger.info(f"Chapter {chapter_number} rejected: {reason}")
        
        return True
    
    def _find_chapter(self, chapter_number: str) -> Optional[Chapter]:
        """Trouve un chapitre par son numÃ©ro"""
        for chapter in self.chapters:
            if chapter.number == chapter_number:
                return chapter
        return None
    
    def is_complete(self) -> bool:
        """VÃ©rifie si tous les chapitres sont validÃ©s"""
        return all(
            chapter.status == ChapterStatus.VALIDATED
            for chapter in self.chapters
        )
    
    def get_progress(self) -> Dict:
        """Retourne la progression"""
        total = len(self.chapters)
        validated = sum(1 for c in self.chapters if c.status == ChapterStatus.VALIDATED)
        
        return {
            'total_chapters': total,
            'validated_chapters': validated,
            'current_chapter': self.current_chapter_index + 1,
            'progress_percent': (validated / total * 100) if total > 0 else 0,
            'is_complete': self.is_complete()
        }
    
    def auto_review_final_report(self, report_markdown: str = None, save_to_file: bool = True) -> dict:
        """
        Auto-review du rapport complet.
        
        Args:
            report_markdown: Contenu Markdown (si None, compile automatiquement)
            save_to_file: Sauvegarde rapport d'amÃ©lioration
        """
        logger.info("=" * 70)
        logger.info("AUTO-REVIEW DU RAPPORT")
        logger.info("=" * 70)
        
        try:
            if report_markdown is None:
                report_markdown = self.compile_report()
            
            review_result = auto_review_report(report_markdown)
            
            if not review_result.get('success'):
                logger.error(f"Auto-review failed: {review_result.get('error')}")
                return review_result
            
            logger.info("[OK] Auto-review completed")
            
            if save_to_file:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"rapport_review_{timestamp}.md"
                
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(f"# Auto-Review\\n\\n{review_result.get('full_review', '')}")
                
                logger.info(f"ğŸ“„ Review saved: {filename}")
                review_result['saved_to'] = filename
            
            return review_result
            
        except Exception as e:
            logger.error(f"Auto-review error: {e}", exc_info=True)
            return {'success': False, 'error': str(e)}
    
    def compile_report(self) -> str:
        """
        Compile tous les chapitres validÃ©s en un rapport final
        
        Returns:
            Rapport complet en Markdown
        """
        if not self.is_complete():
            logger.warning("Attempting to compile incomplete report")
        
        report = f"""# {self.plan.get('titre', 'Rapport Statistique')}

**Date:** {self.plan.get('date', datetime.now().strftime('%Y-%m-%d'))}  
**Auteur:** {self.plan.get('auteur', 'AI Statistical Reporter')}

---

## Table des matiÃ¨res

"""
        
        # Table des matiÃ¨res
        for chapter in self.chapters:
            report += f"{chapter.number}. [{chapter.title}](#{chapter.number.replace('.', '')})\n"
        
        report += "\n---\n\n"
        
        # Contenu des chapitres
        for chapter in self.chapters:
            if chapter.status == ChapterStatus.VALIDATED and chapter.content:
                report += chapter.content + "\n\n---\n\n"
        
        logger.info(f"Report compiled: {len(report)} characters")
        
        return report


# ============================================
# FONCTIONS POUR STREAMLIT
# ============================================

def initialize_workflow(user_id: str, plan: Dict, csv_path: str, cost_controller=None, study_context=None) -> ReportGenerationWorkflow:
    """
    Initialise un workflow de gÃ©nÃ©ration
    
    Args:
        user_id: ID de l'utilisateur
        plan: Plan du rapport
        csv_path: Chemin vers le fichier CSV/Excel
        cost_controller: (Optionnel) ContrÃ´leur de coÃ»ts
        study_context: (Optionnel) Contexte de l'Ã©tude
    
    Usage dans Streamlit:
        if 'workflow' not in st.session_state:
            st.session_state.workflow = initialize_workflow(
                st.session_state.user_id,
                st.session_state.plan,
                st.session_state.csv_path,
                cost_controller=st.session_state.cost_controller,
                study_context=st.session_state.study_context
            )
    """
    return ReportGenerationWorkflow(user_id, plan, csv_path, cost_controller, study_context)


def display_workflow_progress(workflow: ReportGenerationWorkflow):
    """
    Affiche la progression du workflow dans Streamlit
    
    Usage:
        display_workflow_progress(st.session_state.workflow)
    """
    import streamlit as st
    
    progress = workflow.get_progress()
    
    st.progress(
        progress['progress_percent'] / 100,
        text=f"Progression : {progress['validated_chapters']}/{progress['total_chapters']} chapitres validÃ©s"
    )
    
    # Liste des chapitres avec statuts
    for i, chapter in enumerate(workflow.chapters, 1):
        status_emoji = {
            ChapterStatus.PENDING: "â³",
            ChapterStatus.GENERATING: "â–¶ï¸",
            ChapterStatus.GENERATED: "ğŸ‘ï¸",
            ChapterStatus.VALIDATED: "[OK]",
            ChapterStatus.REJECTED: "[ERROR]",
            ChapterStatus.ERROR: "[WARNING]"
        }
        
        emoji = status_emoji.get(chapter.status, "â€¢")
        
        st.markdown(f"{emoji} **{chapter.number}. {chapter.title}** - {chapter.status.value}")


# ============================================
# TESTS
# ============================================

if __name__ == "__main__":
    """Tests du workflow"""
    
    print("="*60)
    print("TEST REPORT GENERATION WORKFLOW - VERSION CORRIGÃ‰E")
    print("="*60)
    
    # Plan exemple
    plan = {
        'titre': 'Test Report',
        'date': '2025-12-27',
        'auteur': 'Test',
        'chapitres': [
            {
                'numero': '1',
                'titre': 'Introduction',
                'sections': [
                    {
                        'titre': 'Contexte',
                        'analyses': ['PrÃ©sentation donnÃ©es', 'Objectifs']
                    }
                ]
            },
            {
                'numero': '2',
                'titre': 'Analyse',
                'sections': [
                    {
                        'titre': 'Statistiques',
                        'analyses': ['Moyennes', 'Ã‰carts-types']
                    }
                ]
            }
        ]
    }
    
    print("\n1. Initialisation workflow...")
    workflow = ReportGenerationWorkflow('test_user', plan, 'test.csv')
    print(f"[OK] {len(workflow.chapters)} chapitres initialisÃ©s")
    
    print("\n2. Progression initiale...")
    progress = workflow.get_progress()
    print(f"[OK] Progression: {progress}")
    
    print("\n3. Chapitre en cours...")
    current = workflow.get_current_chapter()
    print(f"[OK] Chapitre courant: {current.number}. {current.title}")
    
    print("\n[OK] Tests terminÃ©s (gÃ©nÃ©ration complÃ¨te nÃ©cessite E2B + Gemini)")
    print("\nğŸ¯ AMÃ‰LIORATIONS PRINCIPALES :")
    print("   [OK] Gestion robuste des erreurs (KeyError, TypeError)")
    print("   [OK] DÃ©codage des variables encodÃ©es")
    print("   [OK] InterprÃ©tations obligatoires aprÃ¨s chaque Ã©lÃ©ment visuel")
    print("   [OK] RÃ©fÃ©rences correctes (tableau vs graphique)")
    print("   [OK] Support Excel + CSV")
    print("   [OK] Gestion apostrophes dans noms de colonnes")