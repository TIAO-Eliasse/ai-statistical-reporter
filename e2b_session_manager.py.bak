"""
Gestionnaire de sessions E2B avec persistance
VERSION CORRIG√âE - Janvier 2026
‚úÖ Chargement correct de E2B_API_KEY
‚úÖ Gestion robuste des erreurs
"""

import os
import time
import threading
import logging
from datetime import datetime, timedelta
from typing import Dict, Optional
from e2b_code_interpreter import Sandbox
from dotenv import load_dotenv

# ‚úÖ CHARGEMENT DES VARIABLES D'ENVIRONNEMENT
load_dotenv()

# Configuration du logger
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class E2BSessionManager:
    """Gestionnaire centralis√© des sessions E2B"""
    
    def __init__(self):
        self.sessions: Dict[str, Dict] = {}
        self.lock = threading.Lock()
        self.max_idle_time = timedelta(minutes=30)
        self._heartbeat_enabled = False
        
        # ‚úÖ V√âRIFICATION CL√â API AU D√âMARRAGE
        self.api_key = os.getenv("E2B_API_KEY")
        
        if not self.api_key:
            logger.error("=" * 60)
            logger.error("‚ùå ERREUR CRITIQUE : E2B_API_KEY non trouv√©e !")
            logger.error("=" * 60)
            logger.error("Solution :")
            logger.error("1. Cr√©ez un fichier .env √† la racine du projet")
            logger.error("2. Ajoutez : E2B_API_KEY=votre_cl√©_ici")
            logger.error("3. V√©rifiez que python-dotenv est install√©")
            logger.error("=" * 60)
            raise ValueError("E2B_API_KEY manquante dans les variables d'environnement")
        
        logger.info(f"‚úÖ E2B Session Manager initialized")
        logger.info(f"   Cl√© API : {self.api_key[:10]}...{self.api_key[-5:]}")
        logger.info(f"   Heartbeat : d√©sactiv√©")
    
    def get_sandbox_for_user(self, user_id: str) -> Sandbox:
        """
        R√©cup√®re ou cr√©e une sandbox pour un utilisateur
        
        Args:
            user_id: ID de l'utilisateur
        
        Returns:
            Instance de Sandbox E2B
        """
        with self.lock:
            # Si session existe et est active, la r√©utiliser
            if user_id in self.sessions:
                session_info = self.sessions[user_id]
                
                # V√©rifier si la session n'est pas expir√©e
                idle_time = datetime.now() - session_info['last_used']
                if idle_time > self.max_idle_time:
                    logger.warning(f"Session expir√©e pour {user_id}, recr√©ation...")
                    self._cleanup_session(user_id)
                else:
                    session_info['last_used'] = datetime.now()
                    logger.debug(f"R√©utilisation sandbox pour {user_id}")
                    return session_info['sandbox']
            
            # Cr√©er nouvelle session
            logger.info(f"Cr√©ation nouvelle sandbox pour {user_id}")
            
            try:
                # ‚úÖ CORRECTION CRITIQUE : Passer la cl√© API
                sandbox = Sandbox.create(
                    api_key=self.api_key,  # ‚Üê LIGNE CRITIQUE AJOUT√âE
                    timeout=1800  # 30 minutes
                )
                
                self.sessions[user_id] = {
                    'sandbox': sandbox,
                    'created_at': datetime.now(),
                    'last_used': datetime.now(),
                    'heartbeat_count': 0
                }
                
                logger.info(f"‚úÖ Sandbox cr√©√© pour {user_id}: {sandbox.sandbox_id}")
                return sandbox
            
            except Exception as e:
                logger.error(f"‚ùå √âchec cr√©ation sandbox pour {user_id}: {e}")
                logger.error(f"   Cl√© API utilis√©e : {self.api_key[:10]}...")
                raise
    
    def cleanup_session(self, user_id: str):
        """Nettoie une session utilisateur"""
        with self.lock:
            if user_id in self.sessions:
                self._cleanup_session(user_id)
    
    def get_session_info(self, user_id: str) -> Optional[Dict]:
        """R√©cup√®re les informations d'une session"""
        with self.lock:
            if user_id not in self.sessions:
                return None
            
            session_info = self.sessions[user_id]
            
            return {
                'sandbox_id': session_info['sandbox'].sandbox_id,
                'created_at': session_info['created_at'].isoformat(),
                'last_used': session_info['last_used'].isoformat(),
                'idle_time': (datetime.now() - session_info['last_used']).total_seconds(),
                'heartbeat_count': session_info['heartbeat_count'],
            }
    
    def _cleanup_session(self, user_id: str):
        """Nettoie une session (doit √™tre appel√© avec le lock)"""
        if user_id in self.sessions:
            session_info = self.sessions[user_id]
            
            try:
                sandbox = session_info['sandbox']
                sandbox.kill()
                logger.info(f"Sandbox ferm√© pour {user_id}")
            except Exception as e:
                logger.error(f"Erreur fermeture sandbox pour {user_id}: {e}")
            
            del self.sessions[user_id]
    
    def cleanup_all(self):
        """Nettoie toutes les sessions"""
        logger.info("Nettoyage de toutes les sessions...")
        
        with self.lock:
            for user_id in list(self.sessions.keys()):
                self._cleanup_session(user_id)
        
        logger.info("Toutes les sessions nettoy√©es")
    
    def __del__(self):
        """Nettoyage √† la destruction de l'objet"""
        self.cleanup_all()


# Instance globale du gestionnaire
_session_manager = None


def get_session_manager() -> E2BSessionManager:
    """R√©cup√®re l'instance globale du gestionnaire"""
    global _session_manager
    
    if _session_manager is None:
        _session_manager = E2BSessionManager()
    
    return _session_manager


def get_sandbox_for_user(user_id: str) -> Sandbox:
    """Helper function pour r√©cup√©rer une sandbox"""
    return get_session_manager().get_sandbox_for_user(user_id)


def execute_python_code(user_id: str, code: str) -> Dict:
    """
    Ex√©cute le code et retourne les r√©sultats format√©s
    
    Returns:
        {
            'success': bool,
            'output': str,
            'charts': List[str],
            'error': str,
            'execution_time': float
        }
    """
    start_time = time.time()
    
    try:
        sandbox = get_sandbox_for_user(user_id)
        
        logger.info(f"Ex√©cution code pour {user_id} ({len(code)} chars)")
        logger.debug(f"Code : {code[:100]}...")
        
        # Ex√©cution du code
        execution = sandbox.run_code(code)
        
        execution_time = time.time() - start_time
        
        # ‚úÖ Gestion des erreurs Python (IndentationError, SyntaxError, etc.)
        if execution.error:
            error_msg = f"{execution.error.name}: {execution.error.value}"
            
            # Ajouter traceback si disponible
            if hasattr(execution.error, 'traceback') and execution.error.traceback:
                error_msg += f"\n{execution.error.traceback}"
            
            logger.error(f"Erreur d'ex√©cution : {error_msg}")
            
            return {
                'success': False,
                'output': '',
                'charts': [],
                'error': error_msg,
                'execution_time': execution_time
            }
        
        # ‚úÖ Collecte du texte (stdout)
        output_text = ""
        if execution.logs and execution.logs.stdout:
            output_text = "\n".join(execution.logs.stdout)
            logger.info(f"Output captur√© : {len(output_text)} chars")
        
        # ‚úÖ Collecte des graphiques (PNG base64)
        charts = []
        if execution.results:
            for result in execution.results:
                if hasattr(result, 'png') and result.png:
                    charts.append(result.png)
                    logger.info(f"Graphique captur√©")
        
        logger.info(f"‚úÖ Ex√©cution r√©ussie en {execution_time:.2f}s - "
                   f"{len(output_text)} chars, {len(charts)} graphiques")
        
        return {
            'success': True,
            'output': output_text.strip(),
            'charts': charts,
            'error': None,
            'execution_time': execution_time
        }
    
    except Exception as e:
        execution_time = time.time() - start_time
        logger.error(f"‚ùå Erreur lors de l'ex√©cution : {e}")
        
        import traceback
        logger.error(f"Traceback :\n{traceback.format_exc()}")
        
        return {
            'success': False,
            'output': '',
            'charts': [],
            'error': str(e),
            'execution_time': execution_time
        }


def cleanup_user_session(user_id: str):
    """Nettoie la session d'un utilisateur"""
    get_session_manager().cleanup_session(user_id)


def get_user_session_info(user_id: str) -> Optional[Dict]:
    """R√©cup√®re les infos de session d'un utilisateur"""
    return get_session_manager().get_session_info(user_id)


def display_session_status_in_streamlit():
    """Affiche le statut de la session E2B dans Streamlit"""
    try:
        import streamlit as st
    except ImportError:
        return
    
    if 'user_id' not in st.session_state:
        return
    
    user_id = st.session_state.user_id
    session_info = get_user_session_info(user_id)
    
    if session_info:
        with st.expander("üñ•Ô∏è Session E2B", expanded=False):
            col1, col2 = st.columns(2)
            
            with col1:
                st.caption(f"**Sandbox ID:** {session_info['sandbox_id'][:12]}...")
                st.caption(f"**Cr√©√©e:** {session_info['created_at'][:19]}")
            
            with col2:
                st.caption(f"**Derni√®re utilisation:** {session_info['last_used'][:19]}")
                st.caption(f"**Inactivit√©:** {int(session_info['idle_time'])}s")
            
            # Barre de progression du timeout (30 min = 1800s)
            timeout_progress = min(100, (session_info['idle_time'] / 1800) * 100)
            st.progress(timeout_progress / 100)
            
            if timeout_progress > 80:
                st.warning("‚ö†Ô∏è Session proche de l'expiration")


# Export pour compatibilit√©
session_manager = get_session_manager()

# Nettoyage √† la sortie
import atexit
atexit.register(lambda: get_session_manager().cleanup_all())


# ============================================
# TEST
# ============================================

if __name__ == "__main__":
    print("=" * 60)
    print("TEST E2B SESSION MANAGER")
    print("=" * 60)
    
    # Test 1 : V√©rification cl√© API
    print("\nüìù Test 1 : V√©rification cl√© API")
    api_key = os.getenv("E2B_API_KEY")
    
    if not api_key:
        print("‚ùå E2B_API_KEY non trouv√©e")
        print("\nV√©rifiez votre fichier .env :")
        print("1. Doit contenir : E2B_API_KEY=votre_cl√©")
        print("2. Doit √™tre √† la racine du projet")
        print("3. python-dotenv doit √™tre install√©")
        exit(1)
    
    print(f"‚úÖ E2B_API_KEY trouv√©e : {api_key[:10]}...{api_key[-5:]}")
    
    # Test 2 : Cr√©ation sandbox
    print("\nüìù Test 2 : Cr√©ation sandbox")
    try:
        sandbox = get_sandbox_for_user("test_user")
        print(f"‚úÖ Sandbox cr√©√© : {sandbox.sandbox_id}")
    except Exception as e:
        print(f"‚ùå √âchec : {e}")
        exit(1)
    
    # Test 3 : Ex√©cution code simple
    print("\nüìù Test 3 : Ex√©cution code simple")
    result = execute_python_code("test_user", "print('Hello from E2B!')")
    
    if result['success']:
        print(f"‚úÖ Succ√®s")
        print(f"   Output : {result['output']}")
        print(f"   Temps : {result['execution_time']:.2f}s")
    else:
        print(f"‚ùå √âchec : {result['error']}")
    
    # Test 4 : Ex√©cution avec graphique
    print("\nüìù Test 4 : Ex√©cution avec graphique")
    code_graph = """
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 10, 100)
y = np.sin(x)

plt.figure(figsize=(10, 6))
plt.plot(x, y)
plt.title("Test Graphique")
plt.show()

print("Graphique g√©n√©r√©")
"""
    
    result = execute_python_code("test_user", code_graph)
    
    if result['success']:
        print(f"‚úÖ Succ√®s")
        print(f"   Output : {result['output']}")
        print(f"   Charts : {len(result['charts'])} graphique(s)")
        print(f"   Temps : {result['execution_time']:.2f}s")
    else:
        print(f"‚ùå √âchec : {result['error']}")
    
    # Cleanup
    cleanup_user_session("test_user")
    
    print("\n" + "=" * 60)
    print("‚úÖ TOUS LES TESTS R√âUSSIS")
    print("=" * 60)